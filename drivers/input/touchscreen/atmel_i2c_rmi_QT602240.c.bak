/* drivers\input\touchscreen\atmel_i2c_rmi_QT602240.c
 *
 * Copyright (C) 2009 HUAWEI Corporation.
 *
 * This software is licensed under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */

#include <linux/module.h>
#include <linux/delay.h>
#include <linux/hrtimer.h>
#include <linux/i2c.h>
#include <linux/input.h>
#include <linux/interrupt.h>
#include <linux/io.h>
#include <linux/platform_device.h>
#include <linux/atmel_i2c_rmi.h>
#include <linux/ctype.h>
#include <linux/earlysuspend.h>
#include <mach/gpio.h>

/*
 * DEBUG SWITCH
 *
 */ 

#define TS_DEBUG
//#undef TS_DEBUG 
#ifdef TS_DEBUG
#define TS_DEBUG_TS(fmt, args...) printk(KERN_INFO fmt, ##args)
#else
#define TS_DEBUG_TS(fmt, args...)
#endif

#undef TOUCH_12BIT
#ifdef TOUCH_12BIT
#define TS_X_MAX 4095
#define TS_Y_MAX 4095
#else
#define TS_X_MAX 1023
#define TS_Y_MAX 1023
#endif
#define TS_X_OFFSET  3*(TS_X_MAX/LCD_X_MAX)
#define TS_Y_OFFSET  TS_X_OFFSET
#ifdef CONFIG_HUAWEI_TOUCHSCREEN_EXTRA_KEY

/*max y for the key region. total height of the touchscreen is 91.5mm,
and the height of the key region is 8.5mm, TS_Y_MAX * 8.5 /91.5 */
#define TS_KEY_Y_MAX 94//248


#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef min
#define min(a,b) ((a)>(b)?(b):(a))
#endif
#ifndef max
#define max(a,b) ((b)>(a)?(b):(a))
#endif
#ifndef abs
#define abs(a)  ((0 < (a)) ? (a) : -(a))
#endif


#define X_START    (0)
#define X_END      (TS_X_MAX) 
#define Y_START    (TS_Y_MAX-TS_KEY_Y_MAX)
#define Y_END      (TS_Y_MAX)

#define EXTRA_MAX_TOUCH_KEY    4
#define TS_KEY_DEBOUNCE_TIMER_MS 60


/* to define a region of touch panel */
typedef struct
{
    u16 touch_x_start;
    u16 touch_x_end;
    u16 touch_y_start;
    u16 touch_y_end;
} touch_region;

/* to define virt button of touch panel */
typedef struct 
{
    u16  center_x;
    u16  center_y;
    u16  x_width;
    u16  y_width;
    u32   touch_keycode;
} button_region;

/* to define extra touch region and virt key region */
typedef struct
{
    touch_region   extra_touch_region;
    button_region  extra_key[EXTRA_MAX_TOUCH_KEY];
} extra_key_region;

/* to record keycode */
typedef struct {
	u32                 record_extra_key;             /*key value*/   
	bool                bRelease;                     /*be released?*/   
	bool                bSentPress;                  
	bool                touch_region_first;           /* to record first touch event*/
} RECORD_EXTRA_KEYCODE;
/* to init extra region and touch virt key region */
static extra_key_region   touch_extra_key_region =
{
    {X_START, X_END,Y_START,Y_END},								/* extra region */
    {
/* the value 24 (the gap between touch region and key region)maybe need to modify*/
      {(TS_X_MAX*1/8),   (TS_Y_MAX-TS_KEY_Y_MAX/2+26), TS_X_MAX/10, TS_KEY_Y_MAX/3, KEY_BACK},  /*back key */
       {(TS_X_MAX*3/8),   (TS_Y_MAX-TS_KEY_Y_MAX/2+26), TS_X_MAX/10, TS_KEY_Y_MAX/3, KEY_MENU},  /* menu key */
       {(TS_X_MAX*5/8),   (TS_Y_MAX-TS_KEY_Y_MAX/2+26), TS_X_MAX/10, TS_KEY_Y_MAX/3, KEY_F5 },  /* KEY_F2,KEY_HOME home key */
       {(TS_X_MAX*7/8),   (TS_Y_MAX-TS_KEY_Y_MAX/2+26), TS_X_MAX/10, TS_KEY_Y_MAX/3, KEY_SEARCH},  /* Search key */
    },
};

/* to record the key pressed */
//static RECORD_EXTRA_KEYCODE  record_extra_keycode = {KEY_RESERVED, TRUE, TRUE, FALSE};
#endif

#define LCD_X_MAX 479
#define ATMEL_FAMILY_ID 0x80

/*! \brief Returned by get_object_address() if object is not found. */
#define OBJECT_NOT_FOUND   0u

/* Array of I2C addresses where we are trying to find the chip. */
extern uint8_t i2c_addresses[];

/*! Address where object table starts at touch IC memory map. */
#define OBJECT_TABLE_START_ADDRESS      7U

/*! Size of one object table element in touch IC memory map. */
#define OBJECT_TABLE_ELEMENT_SIZE     	6U

/*! Offset to RESET register from the beginning of command processor. */
#define RESET_OFFSET		            0u

/*! Offset to BACKUP register from the beginning of command processor. */
#define BACKUP_OFFSET		1u

/*! Offset to CALIBRATE register from the beginning of command processor. */
#define CALIBRATE_OFFSET	2u

/*! Offset to REPORTALL register from the beginning of command processor. */
#define REPORTATLL_OFFSET	3u

/*! Offset to DEBUG_CTRL register from the beginning of command processor. */
#define DEBUG_CTRL_OFFSET	5u

#define DEBUG_INC_PAGE 0x01
#define DEBUG_DEC_PAGE 0x02
#define DEBUG_DELTAS_MODE 0x10
#define DEBUG_REFER_MODE 0x11
#define DEBUG_CTE_MODE 0x31


#define GEN_MESSAGEPROCESSOR_T5 5
#define GEN_COMMANDPROCESSOR_T6 6
#define GEN_POWERCONFIG_T7 7
#define T7_INSTANCE 0
#define GEN_ACQUISITIONCONFIG_T8 8

#define TOUCH_MULTITOUCHSCREEN_T9 9

#define TOUCH_KEYARRAY_T15 15

#define PROCG_GRIPFACESUPPRESSION_T20 20
#define PROCG_NOISESUPPRESSION_T22 22

#define PROCI_ONETOUCHGESTUREPROCESSOR_T24 24
#define SPT_SELFTEST_T25 25
#define PROCI_TWOTOUCHGESTUREPROCESSOR_T27 27


#define SPT_CTECONFIG_T28 28

#define DEBUG_DIAGNOSTIC_T37 37

#define KEY_RELEASE 0x0
#define KEY_NUHBER1 0x1
#define KEY_NUHBER2 0x2
#define KEY_NUHBER3 0x4
#define KEY_NUHBER4 0x8
//#define KEY_NUHBER5 0x10

struct info_id_t {
	u8 family_id;
	u8 variant_id;
	u8 version;
	u8 build;
	u8 matrix_x_size;
	u8 matrix_y_size;
	u8 num_declared_objects;
};

struct object_t {
	u8 object_type;
	u16 object_address;
	u8 size;
	u8 instances;
	u8 num_report_ids;
};

struct info_block_t {
	struct info_id_t id;
	struct object_t *pobject_table;
	u32 CRC;
};

/*! \brief Struct holding the object type / instance info.
 * 
 * Struct holding the object type / instance info. An array of these maps
 * report id's to object type / instance (array index = report id).  Note
 * that the report ID number 0 is reserved.
 * 
 */

struct report_id_map_t {
   u8 object_type; 	/*!< Object type. */
   u8 instance;   	    /*!< Instance number. */
};

static struct info_block_t info_block;

/*! Pointer to report_id - > object type/instance map structure. */
static struct report_id_map_t *report_id_map = NULL;

/*! Maximum report id number. */
static int max_report_id = 0;

/*! Maximum message length. */
static u8 max_message_length;

static u8 T9_base_reportID = 0;

/*! Message processor address. */
u16 message_processor_address;

/*! Command processor address. */
u16 command_processor_address;

/*! Command processor address. */
u16 debug_diagnostic_address;

/*! Message buffer holding the latest message received. */
u8 *touch_msg = NULL;

/* Unique ID allocation */
static struct i2c_client *g_client;

static struct workqueue_struct *atmel_wq;

static DECLARE_MUTEX(atmel_i2c_lock);

struct atmel_ts_data {
	uint16_t addr;
	struct i2c_client *client;
	struct input_dev *input_dev;
	struct work_struct  work;
	int use_irq;
        
	struct hrtimer timer;	
	int (*power)(struct i2c_client* client, int on);
	unsigned int test;
	unsigned int lock;
	int touch_x;
	int touch_y;
	int touchamplitude;
	int sizeoftouch;
	bool is_support_multi_touch; //multi_touch function switch
#ifdef CONFIG_HUAWEI_TOUCHSCREEN_EXTRA_KEY
	struct input_dev *key_input;
#endif

       struct early_suspend early_suspend;
};

#ifdef CONFIG_HAS_EARLYSUSPEND
static void atmel_ts_early_suspend(struct early_suspend *h);
static void atmel_ts_late_resume(struct early_suspend *h);
#endif

static int atmel_ts_power(struct i2c_client *client, int on);

static inline void touchkey_test(struct atmel_ts_data *ts,
			unsigned long value)
{
	if (value == 0 && ts->test > 0)
	{
		ts->test = value;
		TS_DEBUG_TS("\ntouch key test mode disable!\n");
	}
	else if (value > 0 && ts->test == 0)
	{
		ts->test = value;
		TS_DEBUG_TS("\ntouch key test mode enable!\n");
	}
	else
		TS_DEBUG_TS(KERN_WARNING "%s: getting touch key test command value = %lud\n",__func__, value);
}
static ssize_t touchkey_test_show(struct device *dev,
			struct device_attribute *attr,
			char *buf)
{
	struct atmel_ts_data *ts = dev_get_drvdata(dev);
	if( ts )
	      return sprintf(buf, "%d\n", ts->test);
	else
	      return 0;
}

static ssize_t touchkey_test_store(struct device *dev,
			struct device_attribute *attr,
			const char *buf, size_t size)
{
	struct atmel_ts_data *ts = dev_get_drvdata(dev);
	ssize_t ret = -EINVAL;
	char *after;
	unsigned long state = simple_strtoul(buf, &after, 10);
	size_t count = after - buf;

	if (*after && isspace(*after))
	      count++;

	if (count == size) {
		ret = count;
		touchkey_test(ts, state);
	}

	return ret;
}

static DEVICE_ATTR(test, S_IRUGO | S_IWUSR, touchkey_test_show, touchkey_test_store); 

static inline void touch_lock(struct atmel_ts_data *ts, unsigned long value)
{
	if (value == 0 && ts->lock > 0)
	{
		ts->test = value;
		TS_DEBUG_TS("\ntouch lock mode disable!\n");
	}
	else if (value > 0 && ts->lock == 0)
	{
		ts->test = value;
		TS_DEBUG_TS("\ntouch lock mode enable!\n");
	}
	else
		TS_DEBUG_TS(KERN_WARNING "%s: getting touch lock command value = %lud\n",__func__, value);
}

static ssize_t touch_lock_show(struct device *dev,
			struct device_attribute *attr,
			char *buf)
{
	struct  atmel_ts_data *ts = dev_get_drvdata(dev);
	if( ts )
		return sprintf(buf, "%d\n", ts->lock);
	else
		return 0;
}

static ssize_t touch_lock_store(struct device *dev,
			struct device_attribute *attr,
			const char *buf, size_t size)
{
	struct atmel_ts_data *ts = dev_get_drvdata(dev);
	ssize_t ret = -EINVAL;
	char *after;
	unsigned long state = simple_strtoul(buf, &after, 10);
	size_t count = after - buf;

	if (*after && isspace(*after))
		count++;

	if (count == size) {
		ret = count;
		touch_lock(ts, state);
	}

	return ret;
}

static DEVICE_ATTR(lock, S_IRUGO | S_IWUSR, touch_lock_show, touch_lock_store); 


/*---------------- Function Header -------------------------------------------

	FUNCTION	int write_mem_I2C( u16 Address, u8 ByteCount, u8 *pData )
	PURPOSE		Writes multiple bytes to device at 'I2cAddress'.
				Calls address_slave() to address device to write
				Writes bytes.
	INPUT		Address:    specifies where to write to in the device
				ByteCount: 	number of bytes to read
				Data:       Pointer to write-data (byte) array
	OUTPUT		0 if read completes
				others if failed
	MODIFIES	Nothing
				 
----------------------------------------------------------------------------*/
static
int write_mem_I2C( u16 Address, u8 ByteCount, u8 *pData )
{
	int ret;
	u8 data[3];
	u8 i;
	u8 *ReadDataPtr;
	if( g_client == NULL )	/* Not initialize the client */
		return -1;	
		
	ReadDataPtr = pData;
	for ( i = 0; i < ByteCount; i++)
	{
		data[0] = (Address + i) & 0xff;
		data[1] = (Address + i) >> 8;
		data[2] = *ReadDataPtr++;
		ret = i2c_master_send(g_client, data, 3);
		if(ret<0) {
			TS_DEBUG_TS(KERN_ERR "ATMEL: write reg [%04x] failed %d\n", Address, ret);
			return ret;
		}
	}
	
	return 0;
}

/*---------------- Function Header -------------------------------------------

	FUNCTION	int read_mem_I2C( u16 Address, u8 ByteCount, u8 *pData )
	PURPOSE		Reads multiple bytes from device at 'I2cAddress'.
				Calls write_mem() to set address-pointer = Address
				Calls address_slave() to address device to read
				Reads bytes.
	INPUT		Address:    specifies where to read from in the device
				ByteCount: 	number of bytes to read
				Data:       Pointer to return-data (byte) array
	OUTPUT		0 if read completes
				others if failed
	MODIFIES	Nothing
				 
----------------------------------------------------------------------------*/
static
int read_mem_I2C( u16 Address, u8 ByteCount, u8 *pData )
{ 
	int ret;
	u8 data[2];
	
	if( g_client == NULL )	/* Not initialize the client */	
		return -1;

	data[0] = Address & 0xff;
	data[1] = Address >> 8;
	ret = i2c_smbus_write_byte_data(g_client,data[0],data[1]);
	if(ret) {
		TS_DEBUG_TS(KERN_ERR "ATMEL: read reg [%04x], write address failed %d\n", Address, ret);
		return ret;
	}
	i2c_master_recv(g_client, pData, ByteCount);

	return 0; 
}

static
int write_mem( u16 Address, u8 ByteCount, u8 *pData )
{
	int ret;
	down(&atmel_i2c_lock);
	ret = write_mem_I2C(Address,ByteCount,pData);
	up(&atmel_i2c_lock);
	return ret;
}

static
int read_mem( u16 Address, u8 ByteCount, u8 *pData )
{
	int ret;
	down(&atmel_i2c_lock);
	ret = read_mem_I2C(Address,ByteCount,pData);
	up(&atmel_i2c_lock);
	return ret;
}

/*!
 * \brief Reads the id part of info block.
 * 
 * Reads the id part of the info block (7 bytes) from touch IC to 
 * info_block struct.
 *
 */
static  
int read_id_block(struct info_id_t *id)
{
    read_mem(0, 1, (u8 *) &id->family_id);
    read_mem(1, 1, (u8 *) &id->variant_id);
    read_mem(2, 1, (u8 *) &id->version);
    read_mem(3, 1, (u8 *) &id->build);
    read_mem(4, 1, (u8 *) &id->matrix_x_size);
    read_mem(5, 1, (u8 *) &id->matrix_y_size);
    read_mem(6, 1, (u8 *) &id->num_declared_objects);
                                
    return 0;   
}

/*!
 * \brief Reads the object table element part of info block.
 * 
 * Reads the object table element part of the info block from touch IC to 
 * info_block struct.
 *
 */
static  
int read_object_table_element(u32 address, struct object_t *object_table_element)
{
    read_mem(address + 0, 1, (u8 *) &object_table_element->object_type);
    read_mem(address + 1, 2, (u8 *) &object_table_element->object_address);
    read_mem(address + 3, 1, (u8 *) &object_table_element->size);
    read_mem(address + 4, 1, (u8 *) &object_table_element->instances);
    read_mem(address + 5, 1, (u8 *) &object_table_element->num_report_ids);
                                
    return 0;   
}

/*!
 * \brief CRC calculation routine.
 * 
 * @param crc the current CRC sum.
 * @param byte1 1st byte of new data to add to CRC sum.
 * @param byte2 2nd byte of new data to add to CRC sum.
 * @return crc the new CRC sum.
 * 
 */

u32 CRC_24(u32 crc, u8 byte1, u8 byte2)
{
   static const u32 crcpoly = 0x80001B;
   u32 result;
   u16 data_word;
   
   data_word = (u16) ((u16) (byte2 << 8u) | byte1);
   result = ((crc << 1u) ^ (u32) data_word);
   
   if (result & 0x1000000)
   {
      result ^= crcpoly;
   }
   
   return(result);
}

/*!
 * \brief Calculates the CRC sum for the info block & object table area,
 * and checks it matches the stored CRC.
 * 
 * Global interrupts need to be on when this function is called
 * since it reads the info block & object table area from the touch chip.
 * 
 * @param *crc_pointer Pointer to memory location where 
 *        the calculated CRC sum for the info block & object 
 *        will be stored.
 * @return 0 if calculation succeed, ERROR otherwise .
 * 
 */

static int calculate_infoblock_crc(u32 *crc_pointer)
{

	u32 crc = 0;
	u32 crc_area_size;
	u8 *mem;   
	u32 i;


	/* 7 bytes of version data, 6 * NUM_OF_OBJECTS bytes of object table. */
	crc_area_size = OBJECT_TABLE_START_ADDRESS + info_block.id.num_declared_objects * OBJECT_TABLE_ELEMENT_SIZE;

	mem = (u8 *) kzalloc(crc_area_size, GFP_KERNEL);
	if (mem == NULL)
	{
		TS_DEBUG_TS(KERN_ERR "calculate_infoblock_crc kzalloc failed\n");
		return 1;
	}

	read_mem(0, crc_area_size, mem);

	i = 0;
	while (i < (crc_area_size - 1))
	{
		crc = CRC_24(crc, *(mem + i), *(mem + i + 1));
		i += 2;
	}

	if (crc_area_size % 2 == 1)
	{
		crc = CRC_24(crc, *(mem + i), 0);
	}
	kfree(mem);

	/* Return only 24 bit CRC. */
	*crc_pointer = (crc & 0x00FFFFFF);
	return 0;
}

/*!
 * \brief Returns the start address of the selected object.
 * 
 * Returns the start address of the selected object and instance 
 * number in the touch chip memory map.  
 *
 * @param object_type the object ID number.
 * @param instance the instance number of the object.
 * 
 * @return object address, or OBJECT_NOT_FOUND if object/instance not found.
 * 
 */

u16 get_object_address(u8 object_type, u8 instance)
{
   u8 object_table_index = 0;
   u8 address_found = 0;
   u16 address = OBJECT_NOT_FOUND;
   
   struct object_t *object_table;
   struct object_t obj;
   object_table = info_block.pobject_table;
   while ((object_table_index < info_block.id.num_declared_objects) &&
          !address_found)
   {
      obj = object_table[object_table_index];
      /* Does object type match? */
      if (obj.object_type == object_type)
      {
         address_found = 1;

         /* Are there enough instances defined in the FW? */
         if (obj.instances >= instance)
         {
            address = obj.object_address + (obj.size + 1) * instance;
         }
      }
      object_table_index++;
   }

   return(address);
}

/*!
 * \brief Reads message from the message processor.
 * 
 * This function reads a message from the message processor and calls
 * the message handler function provided by application earlier.
 *
 * @return MESSAGE_READ_OK if driver setup correctly and message can be read 
 * without problems, or MESSAGE_READ_FAILED if setup not done or incorrect, 
 * we are both polling the CHANGE line and monitoring it with interrupt that
 * or if there's a previous message read still ongoing (this can happen if
 * is triggered by falling edge).
 * 
 */

static int get_message(void)
{
	read_mem(message_processor_address, max_message_length, touch_msg);
	return 0;
}


/*!
 * \brief Returns the size of the selected object in the touch chip memory map.
 * 
 * Returns the size of the selected object in the touch chip memory map.
 *
 * @param object_type the object ID number.
 * 
 * @return object size, or OBJECT_NOT_FOUND if object not found.
 * 
 */

static u8 get_object_size(u8 object_type)
{
   u8 object_table_index = 0;
   u8 object_found = 0;
   u16 size = OBJECT_NOT_FOUND;
   
   struct object_t *object_table;
   struct object_t obj;
   object_table = info_block.pobject_table;
   while ((object_table_index < info_block.id.num_declared_objects) &&
          !object_found)
   {
      obj = object_table[object_table_index];
      /* Does object type match? */
      if (obj.object_type == object_type)
      {
         object_found = 1;
         size = obj.size + 1;
      }
      object_table_index++;
   }

   return(size);
}

/*!
 * \brief Writes power config. 
 * 
 * @param cfg power config struct.
 * 
 * @return 0 if successful.
 * 
 */

int write_power_config(int on)
{
	u16 object_address;
	u8 *tmp = NULL;
	u8 object_size;
   
	object_address = get_object_address(GEN_POWERCONFIG_T7, T7_INSTANCE);
	object_size = get_object_size(GEN_POWERCONFIG_T7);

	if (object_size < 3)
	{
		TS_DEBUG_TS(KERN_ERR "write_power_config: object_size: 0x%02x\n", object_size);
		return 1;
	}

	if (object_address == 0)
	{
		TS_DEBUG_TS(KERN_ERR "write_power_config: object_address is zero\n");
		return 1;
	}

	tmp = (u8 *) kzalloc(object_size, GFP_KERNEL);
	if (tmp == NULL)
	{
		TS_DEBUG_TS(KERN_ERR "write_power_config: kzalloc for tmp failed\n");
		return 1;
	}
	memset(tmp, 0, object_size);
    if(on)
    {
	    *(tmp + 0) = 50; //0xff//Idle Acquisition
	    *(tmp + 1) = 10; //0xff//Active Acquisition
	    *(tmp + 2) = 50; //0x32//Active to Idle Timeout
    }
    else
    {
        *(tmp + 0) = 0; //0xff//Idle Acquisition
        *(tmp + 1) = 0; //0xff//Active Acquisition
        *(tmp + 2) = 50; //0x32//Active to Idle Timeout            
    }
	write_mem(object_address, object_size, tmp);

	kfree(tmp);
	
	return 0;
}

/*!
 * \brief Writes power config. 
 * 
 * @param cfg power config struct.
 * 
 * @return 0 if successful.
 * 
 */

int write_acquisition_config(u8 instance)
{
	u16 object_address;
	u8 *tmp = NULL;
	u8 object_size;
   
	object_address = get_object_address(GEN_ACQUISITIONCONFIG_T8, instance);
	object_size = get_object_size(GEN_ACQUISITIONCONFIG_T8);

	if (object_size < 8)
	{
		TS_DEBUG_TS(KERN_ERR "write_acquisition_config: object_size: 0x%02x\n", object_size);
		return 1;
	}

	if (object_address == 0)
	{
		TS_DEBUG_TS(KERN_ERR "write_acquisition_config: object_address is zero\n");
		return 1;
	}

	tmp = (u8 *) kzalloc(object_size, GFP_KERNEL);
	if (tmp == NULL)
	{
		TS_DEBUG_TS(KERN_ERR "write_acquisition_config: kzalloc for tmp failed\n");
		return 1;
	}
	memset(tmp, 0, object_size);
	
	*(tmp + 0) = 6; //chrgtime
	*(tmp + 1) = 5; //Reserved
	*(tmp + 2) = 5; //tchdrift
	*(tmp + 3) = 10; //driftst
	*(tmp + 4) = 0; //tchautocal
	*(tmp + 5) = 0; //sync
	*(tmp + 6) = 10; //0x0a//ATCHCALST
	*(tmp + 7) = 15; //0x0f//ATCHCALSTHR


	write_mem(object_address, object_size, tmp);

	kfree(tmp);
	
	return 0;
}

/*!
 * \brief read multitouchscreen config. 
 * 
 * 
 * This function will read the configuration of multitouchscreen
 * instance number.
 * 
 * @param instance the instance number of the multitouchscreen.
 * @param cfg multitouchscreen config struct.
 * @return 0 if successful.
 * 
 */

int read_multitouchscreen_config(u8 instance)
{
	u16 object_address = 0;
	u8 *tmp = NULL;
	u8 object_size;
	int i;

	object_size = get_object_size(TOUCH_MULTITOUCHSCREEN_T9);
	if (object_size < 30)
	{
		TS_DEBUG_TS(KERN_ERR "read_multitouchscreen_config: object_size: 0x%02x\n", object_size);
		return 1;
	}
	
	object_address = get_object_address(TOUCH_MULTITOUCHSCREEN_T9, instance);
	if (object_address == 0)
	{
		TS_DEBUG_TS(KERN_ERR "read_multitouchscreen_config: object_address is zero\n");
		return 1;
	}

	tmp = (u8 *) kzalloc(object_size, GFP_KERNEL);
	if (tmp == NULL)
	{
		TS_DEBUG_TS(KERN_ERR "read_multitouchscreen_config: kzalloc for tmp failed\n");
		return 1;
	}
	memset(tmp, 0, object_size);

	read_mem(object_address, object_size, tmp);

	for (i = 0; i < object_size; i++)
	{
		TS_DEBUG_TS(KERN_ERR "T9[%d] = 0x%02x\n", i, *(tmp + i));		
	}

	kfree(tmp);

	return 0;
}

/*!
 * \brief Writes multitouchscreen config. 
 * 
 * 
 * This function will write the given configuration to given multitouchscreen
 * instance number.
 * 
 * @param instance the instance number of the multitouchscreen.
 * @param cfg multitouchscreen config struct.
 * @return 0 if successful.
 * 
 */

int write_multitouchscreen_config(u8 instance)
{
	u16 object_address = 0;
	u8 *tmp = NULL;
	u8 object_size;

	object_size = get_object_size(TOUCH_MULTITOUCHSCREEN_T9);
	if (object_size < 30)
	{
		TS_DEBUG_TS(KERN_ERR "write_multitouchscreen_config: object_size: 0x%02x\n", object_size);
		return 1;
	}
	
	object_address = get_object_address(TOUCH_MULTITOUCHSCREEN_T9, instance);
	if (object_address == 0)
	{
		TS_DEBUG_TS(KERN_ERR "write_multitouchscreen_config: object_address is zero\n");
		return 1;
	}

	tmp = (u8 *) kzalloc(object_size, GFP_KERNEL);
	if (tmp == NULL)
	{
		TS_DEBUG_TS(KERN_ERR "write_multitouchscreen_config: kzalloc for tmp failed\n");
		return 1;
	}
	memset(tmp, 0, object_size);
	
	*(tmp + 0) =0x8b; //0x83//ctrl
	*(tmp + 1) = 0; //xorigin
	*(tmp + 2) = 0; //yorigin
	*(tmp + 3) = 17; //xsize
	*(tmp + 4) = 12; //ysize
	*(tmp + 5) = 0; //akscfg
	*(tmp + 6) = 30; //blen
	*(tmp + 7) = 50; //0x1d; //tchthr
	*(tmp + 8) = 2; //tchdi
	*(tmp + 9) = 1; //orientate
	*(tmp + 10) = 0; //mrgtimeout
	*(tmp + 11) = 0x05; //movhysti
	*(tmp + 12) = 1; //movhystn
	*(tmp + 13) = 0; //movfilter
	*(tmp + 14) = 2; //numtouch
	*(tmp + 15) = 10; //mrghyst
	*(tmp + 16) = 10; //mrgthr
	*(tmp + 17) = 10; //tchamphyst
	*(tmp + 18) = 0; //xres
	*(tmp + 19) = 0; //xres
	*(tmp + 20) = 0; //yres
	*(tmp + 21) = 0; //yres
	*(tmp + 22) = 0; //xloclip
	*(tmp + 23) = 0; //xhiclip
	*(tmp + 24) = 0; //yloclip
	*(tmp + 25) = 0; //yhiclip
	*(tmp + 26) = 0; //xedgectrl
	*(tmp + 27) = 0; //xedgedist
	*(tmp + 28) = 0; //yedgectrl
	*(tmp + 29) = 0; //yedgedist

	write_mem(object_address, object_size, tmp);

	kfree(tmp);

	return 0;
}

/*!
 * \brief Writes keyarray config. 
 * 
 * 
 * This function will write the given configuration to given keyarray
 * instance number.
 * 
 * @param instance the instance number of the keyarray.
 * @param cfg keyarray config struct.
 * @return 0 if successful.
 * 
 */

int write_keyarray_config(u8 instance)
{
	u16 object_address = 0;
	u8 *tmp = NULL;
	u8 object_size;

	object_size = get_object_size(TOUCH_KEYARRAY_T15);
	if (object_size < 11)
	{
		TS_DEBUG_TS(KERN_ERR "write_keyarray_config: object_size: 0x%02x\n", object_size);
		return 1;
	}
	
	object_address = get_object_address(TOUCH_KEYARRAY_T15, instance);
	if (object_address == 0)
	{
		TS_DEBUG_TS(KERN_ERR "write_keyarray_config: object_address is zero\n");
		return 1;
	}

	tmp = (u8 *) kzalloc(object_size, GFP_KERNEL);
	if (tmp == NULL)
	{
		TS_DEBUG_TS(KERN_ERR "write_keyarray_config: kzalloc for tmp failed\n");
		return 1;
	}
	memset(tmp, 0, object_size);

	*(tmp + 0) = 0x00; //ctrl
	*(tmp + 1) = 0x03; //xorigin
	*(tmp + 2) = 0x0b; //yorigin
	*(tmp + 3) = 0x00; //xsize
	*(tmp + 4) = 0x00; //ysize
	*(tmp + 5) = 0; //akscfg
	*(tmp + 6) = 0x10; //blen
	*(tmp + 7) = 0x28; //tchthr
	*(tmp + 8) = 0x02; //tchdi
	*(tmp + 9) = 0; //reserved1
	*(tmp + 10) = 0; //reserved2

	write_mem(object_address, object_size, tmp);

	kfree(tmp);

	return 0;
}

/*!
 * \brief Writes gripfacesuppression config. 
 * 
 * 
 * This function will write the given configuration to given gripfacesuppression
 * instance number.
 * 
 * @param instance the instance number of the gripfacesuppression.
 * @param cfg gripfacesuppression config struct.
 * @return 0 if successful.
 * 
 */

int write_gripfacesuppression_config(u8 instance)
{
	u16 object_address = 0;
	u8 *tmp = NULL;
	u8 object_size;

	object_size = get_object_size(PROCG_GRIPFACESUPPRESSION_T20);
	if (object_size < 12)
	{
		TS_DEBUG_TS(KERN_ERR "write_gripfacesuppression_config: object_size: 0x%02x\n", object_size);
		return 1;
	}
	
	object_address = get_object_address(PROCG_GRIPFACESUPPRESSION_T20, instance);
	if (object_address == 0)
	{
		TS_DEBUG_TS(KERN_ERR "write_gripfacesuppression_config: object_address is zero\n");
		return 1;
	}

	tmp = (u8 *) kzalloc(object_size, GFP_KERNEL);
	if (tmp == NULL)
	{
		TS_DEBUG_TS(KERN_ERR "write_gripfacesuppression_config: kzalloc for tmp failed\n");
		return 1;
	}
	memset(tmp, 0, object_size);

	*(tmp + 0) = 0x03; //0x05; //ctrl
	*(tmp + 1) = 0; //xlogrip
	*(tmp + 2) = 0; //xhigrip
	*(tmp + 3) = 0; //ylogrip
	*(tmp + 4) = 0; //yhigrip
	*(tmp + 5) = 0; //maxtchs
	*(tmp + 6) = 0; //reserved
	*(tmp + 7) = 0x55; //szthr1
	*(tmp + 8) = 0x28; //szthr2
	*(tmp + 9) = 0x04; //shpthr1
	*(tmp + 10) = 0x0f; //shpthr2
	*(tmp + 11) = 0; //supextto

	write_mem(object_address, object_size, tmp);

	kfree(tmp);

	return 0;
}

/*!
 * \brief Writes noisesuppression config. 
 * 
 * 
 * This function will write the given configuration to given noisesuppression
 * instance number.
 * 
 * @param instance the instance number of the noisesuppression.
 * @param cfg noisesuppression config struct.
 * @return 0 if successful.
 * 
 */

int write_noisesuppression_config(u8 instance)
{
	u16 object_address = 0;
	u8 *tmp = NULL;
	u8 object_size;

	object_size = get_object_size(PROCG_NOISESUPPRESSION_T22);
	if (object_size < 17)
	{
		TS_DEBUG_TS(KERN_ERR "write_noisesuppression_config: object_size: 0x%02x\n", object_size);
		return 1;
	}
	
	object_address = get_object_address(PROCG_NOISESUPPRESSION_T22, instance);
	if (object_address == 0)
	{
		TS_DEBUG_TS(KERN_ERR "write_noisesuppression_config: object_address is zero\n");
		return 1;
	}

	tmp = (u8 *) kzalloc(object_size, GFP_KERNEL);
	if (tmp == NULL)
	{
		TS_DEBUG_TS(KERN_ERR "write_noisesuppression_config: kzalloc for tmp failed\n");
		return 1;
	}
	memset(tmp, 0, object_size);

	*(tmp + 0) = 0x05; //0x05; //ctrl
	*(tmp + 1) = 0; //reserved
	*(tmp + 2) = 0; //reserved
	*(tmp + 3) = 0x19; //GCAFUL
	*(tmp + 4) = 0x00; //GCAFUL
	*(tmp + 5) = 0xe7; //GCAFLL
	*(tmp + 6) = 0xff; //GCAFLL
	*(tmp + 7) = 4; //actvgcafvalid
	*(tmp + 8) = 20; //noisethr
	*(tmp + 9) = 0; //reserved
	*(tmp + 10) = 0; //freqhopscale
	*(tmp + 11) = 0; //freq burst0
	*(tmp + 12) = 14; //freq burst1
	*(tmp + 13) = 20; //freq burst2
	*(tmp + 14) = 255; //freq burst3
	*(tmp + 15) = 255; //freq burst4
	*(tmp + 16) = 4; //idlegcafvalid
	write_mem(object_address, object_size, tmp);

	kfree(tmp);

	return 0;
}

/*!
 * \brief read onetouchgesture config. 
 * 
 * 
 * This function will read the configuration of onetouchgesture
 * instance number.
 * 
 * @param instance the instance number of the onetouchgesture.
 * @param cfg onetouchgesture config struct.
 * @return 0 if successful.
 * 
 */

int read_onetouchgesture_config(u8 instance)
{
	u16 object_address = 0;
	u8 *tmp = NULL;
	u8 object_size;
	int i;

	object_size = get_object_size(PROCI_ONETOUCHGESTUREPROCESSOR_T24);
	if (object_size < 19)
	{
		TS_DEBUG_TS(KERN_ERR "read_onetouchgesture_config: object_size: 0x%02x\n", object_size);
		return 1;
	}
		TS_DEBUG_TS(KERN_ERR "read_onetouchgesture_config: 1object_size: 0x%02x\n", object_size);
	
	object_address = get_object_address(PROCI_ONETOUCHGESTUREPROCESSOR_T24, instance);
	if (object_address == 0)
	{
		TS_DEBUG_TS(KERN_ERR "read_onetouchgesture_config: object_address is zero\n");
		return 1;
	}

	tmp = (u8 *) kzalloc(object_size, GFP_KERNEL);
	if (tmp == NULL)
	{
		TS_DEBUG_TS(KERN_ERR "read_onetouchgesture_config: kzalloc for tmp failed\n");
		return 1;
	}
	memset(tmp, 0, object_size);

	read_mem(object_address, object_size, tmp);

	for (i = 0; i < object_size; i++)
	{
		TS_DEBUG_TS(KERN_ERR "T24[%d] = 0x%02x\n", i, *(tmp + i));		
	}

	kfree(tmp);

	return 0;
}

/*!
 * \brief read sptselftest config. 
 * 
 * 
 * This function will read the configuration of sptselftest
 * instance number.
 * 
 * @param instance the instance number of the sptselftest.
 * @param cfg sptselftest config struct.
 * @return 0 if successful.
 * 
 */

int read_sptselftest_config(u8 instance)
{
	u16 object_address = 0;
	u8 *tmp = NULL;
	u8 object_size;
	int i;

	object_size = get_object_size(SPT_SELFTEST_T25);
	if (object_size < 14)
	{
		TS_DEBUG_TS(KERN_ERR "read_sptselftest_config: object_size: 0x%02x\n", object_size);
		return 1;
	}
		TS_DEBUG_TS(KERN_ERR "read_sptselftest_config: 1object_size: 0x%02x\n", object_size);
	
	object_address = get_object_address(SPT_SELFTEST_T25, instance);
	if (object_address == 0)
	{
		TS_DEBUG_TS(KERN_ERR "read_sptselftest_config: object_address is zero\n");
		return 1;
	}

	tmp = (u8 *) kzalloc(object_size, GFP_KERNEL);
	if (tmp == NULL)
	{
		TS_DEBUG_TS(KERN_ERR "read_sptselftest_config: kzalloc for tmp failed\n");
		return 1;
	}
	memset(tmp, 0, object_size);

	read_mem(object_address, object_size, tmp);

	for (i = 0; i < object_size; i++)
	{
		TS_DEBUG_TS(KERN_ERR "T25[%d] = 0x%02x\n", i, *(tmp + i));		
	}

	kfree(tmp);

	return 0;
}

/*!
 * \brief read twotouchgesture config. 
 * 
 * 
 * This function will read the configuration of twotouchgesture
 * instance number.
 * 
 * @param instance the instance number of the twotouchgesture.
 * @param cfg twotouchgesture config struct.
 * @return 0 if successful.
 * 
 */

int read_twotouchgesture_config(u8 instance)
{
	u16 object_address = 0;
	u8 *tmp = NULL;
	u8 object_size;
	int i;

	object_size = get_object_size(PROCI_TWOTOUCHGESTUREPROCESSOR_T27);
	if (object_size < 7)
	{
		TS_DEBUG_TS(KERN_ERR "read_twotouchgesture_config: object_size: 0x%02x\n", object_size);
		return 1;
	}
		TS_DEBUG_TS(KERN_ERR "read_twotouchgesture_config: 1object_size: 0x%02x\n", object_size);
	
	object_address = get_object_address(PROCI_TWOTOUCHGESTUREPROCESSOR_T27, instance);
	if (object_address == 0)
	{
		TS_DEBUG_TS(KERN_ERR "read_twotouchgesture_config: object_address is zero\n");
		return 1;
	}

	tmp = (u8 *) kzalloc(object_size, GFP_KERNEL);
	if (tmp == NULL)
	{
		TS_DEBUG_TS(KERN_ERR "read_twotouchgesture_config: kzalloc for tmp failed\n");
		return 1;
	}
	memset(tmp, 0, object_size);

	read_mem(object_address, object_size, tmp);

	for (i = 0; i < object_size; i++)
	{
		TS_DEBUG_TS(KERN_ERR "T27[%d] = 0x%02x\n", i, *(tmp + i));		
	}

	kfree(tmp);

	return 0;
}

/*!
 * \brief Writes CTE config. 
 * 
 * 
 * This function will write the given configuration to given CTE
 * instance number.
 * 
 * @param instance the instance number of the CTE.
 * @param cfg CTE config struct.
 * @return 0 if successful.
 * 
 */

int write_CTE_config(u8 instance)
{
	u16 object_address = 0;
	u8 *tmp = NULL;
	u8 object_size;

	object_size = get_object_size(SPT_CTECONFIG_T28);
	if (object_size < 6)
	{
		TS_DEBUG_TS(KERN_ERR "write_CTE_config: object_size: 0x%02x\n", object_size);
		return 1;
	}
	
	object_address = get_object_address(SPT_CTECONFIG_T28, instance);
	if (object_address == 0)
	{
		TS_DEBUG_TS(KERN_ERR "write_CTE_config: object_address is zero\n");
		return 1;
	}

	tmp = (u8 *) kzalloc(object_size, GFP_KERNEL);
	if (tmp == NULL)
	{
		TS_DEBUG_TS(KERN_ERR "write_CTE_config: kzalloc for tmp failed\n");
		return 1;
	}
	memset(tmp, 0, object_size);
	*(tmp + 0) = 0; //ctrl
	*(tmp + 1) = 0; //cmd
	*(tmp + 2) = 1; //mode
	*(tmp + 3) = 4; //idlegcafdepth
	*(tmp + 4) = 32; //actvgcafdepth
	*(tmp + 5) = 10; //voltage

	write_mem(object_address, object_size, tmp);

	kfree(tmp);

	return 0;
}

/*!
 * \brief Resets the chip.
 * 
 *  This function will send a reset command to touch chip.
 *
 * @return WRITE_MEM_OK if writing the command to touch chip was successful.
 * 
 */

int reset_chip(void)
{
   u8 data = 1u;
   return(write_mem(command_processor_address + RESET_OFFSET, 1, &data));
}


/*!
 * \brief Calibrates the chip.
 * 
 * This function will send a calibrate command to touch chip.
 * 
 * @return WRITE_MEM_OK if writing the command to touch chip was successful.
 * 
 */

int calibrate_chip(void)
{
   u8 data = 1u;
   return(write_mem(command_processor_address + CALIBRATE_OFFSET, 1, &data));
   
}

/*!
 * \brief Backups config area.
 * 
 * This function will send a command to backup the configuration to
 * non-volatile memory.
 * 
 * @return WRITE_MEM_OK if writing the command to touch chip was successful.
 * 
 */

int backup_config(void)
{
   
   /* Write 0x55 to BACKUPNV register to initiate the backup. */
   u8 data = 0x55u;
   return(write_mem(command_processor_address + BACKUP_OFFSET, 1, &data));
}

/*!
 * \brief debug config area.
 * 
 * 
 * @return WRITE_MEM_OK if writing the command to touch chip was successful.
 * 
 */

int debug_config(u8 data)
{
   return(write_mem(command_processor_address + DEBUG_CTRL_OFFSET, 1, &data));
}

/*!
 * \brief Return report id of given object/instance.
 * 
 *  This function will return a report id corresponding to given object type
 *  and instance, or 
 * 
 * @param object_type the object type identifier.
 * @param instance the instance of object.
 * 
 * @return report id, or 255 if the given object type does not have report id,
 * of if the firmware does not support given object type / instance.
 * 
 */

u8 type_to_report_id(u8 object_type, u8 instance)
{
	u8 report_id = 1;
	u8 report_id_found = 0;

	while((report_id <= max_report_id) && (report_id_found == 0))
	{
		if((report_id_map[report_id].object_type == object_type) &&
			(report_id_map[report_id].instance == instance))
		{
			report_id_found = 1;
		}
		else
		{
			report_id++;	
		}
	}
	if (report_id_found)
	{
		return(report_id);
	}
	else
	{
		return 0xff;
	}
}




/*!
 * \brief Maps report id to object type and instance.
 * 
 *  This function will return an object type id and instance corresponding
 *  to given report id.
 * 
 * @param report_id the report id.
 * @param *instance pointer to instance variable. This function will set this
 *        to instance number corresponding to given report id.
 * @return the object type id, or 255 if the given report id is not used
 * at all.
 * 
 */

u8 report_id_to_type(u8 report_id, u8 *instance)
{
	if (report_id <= max_report_id)
	{
		*instance = report_id_map[report_id].instance;
		return(report_id_map[report_id].object_type);
	}
	else
	{
		return 0xff;
	}   
}

/*! 
 * \brief Return the maximum report id in use in the touch chip.
 * 
 * @return maximum_report_id 
 * 
 */

uint8_t get_max_report_id(void)
{
	return max_report_id;
}

static void touch_input_report_key(struct atmel_ts_data *ts, unsigned int code, int value)
{
#if 0
	if (ts->test > 0) 
		input_report_key(ts->input_dev, code + 0x80, value);
	else	
	 	input_report_key(ts->input_dev, code, value);	
#endif
	input_report_key(ts->input_dev, code, value);
}

static int atmel_ts_initchip(void)
{
	write_acquisition_config(0);
	write_power_config(1);
	write_multitouchscreen_config(0);
	write_noisesuppression_config(0);
	write_CTE_config(0);
	backup_config();
	reset_chip();

	msleep(50);

	calibrate_chip();
	msleep(50);

	return 0;
}

#ifdef CONFIG_HUAWEI_TOUCHSCREEN_EXTRA_KEY
/*===========================================================================
FUNCTION      is_in_extra_region
DESCRIPTION
              是否在附加TOUCH区
DEPENDENCIES
  None
RETURN VALUE
  true or false
SIDE EFFECTS
  None
===========================================================================*/
static bool is_in_extra_region(int pos_x, int pos_y)
{
    if (pos_x >= touch_extra_key_region.extra_touch_region.touch_x_start
        && pos_x <= touch_extra_key_region.extra_touch_region.touch_x_end
        && pos_y >= touch_extra_key_region.extra_touch_region.touch_y_start
        && pos_y <= touch_extra_key_region.extra_touch_region.touch_y_end)
    {
		TS_DEBUG_TS("the point is_in_extra_region \n");
		return TRUE;
    }

    return FALSE;
}
/*===========================================================================
FUNCTION      touch_get_extra_keycode
DESCRIPTION
              取得附加区键值
DEPENDENCIES
  None
RETURN VALUE
  KEY_VALUE
SIDE EFFECTS
  None
===========================================================================*/
static u32 touch_get_extra_keycode(int pos_x, int pos_y)
{
    int i = 0;
    u32  touch_keycode = KEY_RESERVED;
    for (i=0; i<EXTRA_MAX_TOUCH_KEY; i++)
    {
        if (abs(pos_x - touch_extra_key_region.extra_key[i].center_x) <= touch_extra_key_region.extra_key[i].x_width
         && abs(pos_y - touch_extra_key_region.extra_key[i].center_y) <= touch_extra_key_region.extra_key[i].y_width )
        {
	        touch_keycode = touch_extra_key_region.extra_key[i].touch_keycode;
	        break;
        }
    }
	
	TS_DEBUG_TS("touch_keycode = %d \n",touch_keycode);
    return touch_keycode;
}
#endif

static void atmel_ts_work_func(struct work_struct *work)
{
	u8 ins=0;
	u8 obj;
	u8 x_MSB=0;
	u8 y_MSB=0;
	u8 xy_LSB=0;
	u8 status=0;
	u8 component=0;
	u8 keys;
	static u32 key_pressed = 0;
	static bool multi_touch_mode = FALSE;
	static bool is_multi_touch = FALSE;
	static bool first_point_pressed = FALSE;
	static bool second_point_pressed = FALSE;
	static bool has_reported_point1 = FALSE;
	static bool has_reported_point2 = FALSE;
	static bool first_time_into_multi_touch = TRUE;
#ifdef CONFIG_HUAWEI_TOUCHSCREEN_EXTRA_KEY
	u32 key_tmp;
	static u32 key_pressed1 = 0;
#endif

	u8 point_index = 1;
	struct atmel_ts_data *ts = container_of(work, struct atmel_ts_data, work);
	
	get_message();
	obj = report_id_to_type(*touch_msg, &ins);
	//TS_DEBUG_TS("report_id = 0x%02x, obj = 0x%02x, ins = 0x%02x\n", *touch_msg, obj, ins);
	switch (obj)
	{
		case GEN_COMMANDPROCESSOR_T6:
			status = *(touch_msg + 1);
			TS_DEBUG_TS("T6 status = 0x%02x\n", status);

			if (0x80 & status)
			{
				struct atmel_i2c_rmi_platform_data *pdata;
				
				pdata = g_client->dev.platform_data;
				if(pdata->power)
				{
					pdata->power(0);
					msleep(50);
					pdata->power(1);
				}
				TS_DEBUG_TS("chip reset, need reinit\n");
				atmel_ts_initchip();
			}

			break;
			
		case TOUCH_MULTITOUCHSCREEN_T9:
			point_index = *touch_msg - T9_base_reportID + 1;

			if (point_index > 2)
			{
				//only support 2 point now
				TS_DEBUG_TS("too many point\n");
				break;
			}
						
			status = *(touch_msg + 1);
			x_MSB = *(touch_msg + 2);
			y_MSB = *(touch_msg + 3);
			xy_LSB = *(touch_msg + 4);
			ts->sizeoftouch = *(touch_msg + 5);
			ts->touchamplitude = *(touch_msg + 6);
			component = *(touch_msg + 7);
#ifdef TOUCH_12BIT
			ts->touch_x = (x_MSB << 4) + ((xy_LSB >> 4) & 0x0f);
			ts->touch_y = (y_MSB << 4) + (xy_LSB & 0x0f);
#else		
			ts->touch_x = (x_MSB << 2) + ((xy_LSB >> 6) & 0x03);
			ts->touch_y = (y_MSB << 2) + ((xy_LSB >> 2) & 0x03);
#endif
			//TS_DEBUG_TS("0x%02x, 0x%02x, 0x%02x\n", ts->sizeoftouch, ts->touchamplitude, component);
			TS_DEBUG_TS("version 2;point %d released : %s,x=%04d,  y=%04d\n", 
			point_index,((1 << 5) & status) ? "yes":"no", ts->touch_x, ts->touch_y);
                    

            
#ifdef CONFIG_HUAWEI_TOUCHSCREEN_EXTRA_KEY
			if(is_in_extra_region(ts->touch_x, ts->touch_y))
			{
				key_tmp = touch_get_extra_keycode(ts->touch_x, ts->touch_y);
				TS_DEBUG_TS("the key is :%d\n", key_tmp);
				if ((1 << 5) & status)//release bit
				{
					if(1 == key_pressed1)
					{
						input_report_key(ts->key_input, key_tmp, 0);
						key_pressed1 = 0;
					}
				}
				else
				{
					if(0 == key_pressed1)
					{
						input_report_key(ts->key_input, key_tmp, 1);
						key_pressed1 = 1;
					}
				}         
				input_sync(ts->key_input);			
			}
			else
#endif

			{
				if(ts->is_support_multi_touch)
				{
                    /*the 5-bit in STATUS register specifies the current point just released*/
					if((1 == point_index) && !((1 << 5) & status))
						first_point_pressed = TRUE;
					else if((1 == point_index) && ((1 << 5) & status))
						first_point_pressed = FALSE;

					if((2 == point_index) && !((1 << 5) & status))
						second_point_pressed = TRUE;
					else if((2 == point_index) && ((1 << 5) & status))
						second_point_pressed = FALSE;
				    /*when two points are pressed, multi_touch mode is triggered.*/
					if(first_point_pressed && second_point_pressed)
					{
						multi_touch_mode = TRUE;
						is_multi_touch = TRUE;
					}
					else
						is_multi_touch = FALSE;


					if(multi_touch_mode)
					{

                        if(is_multi_touch)
						{
						    TS_DEBUG_TS("enter multi_touch\n");
                        
						    if(first_time_into_multi_touch)
						    {
						        /*if it's the first time getting into this multi_touch mode, 
						          we should release the former point first.*/
						        input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
						        input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0);
						        input_mt_sync(ts->input_dev);
						        input_sync(ts->input_dev);
						        first_time_into_multi_touch = FALSE;
						    }
                       
						    if((1 == point_index) && !has_reported_point1)
						    {
						        TS_DEBUG_TS("report point 1\n");
						        input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, ts->touchamplitude);
						        input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, ts->sizeoftouch);
						        input_report_abs(ts->input_dev, ABS_MT_POSITION_X, ts->touch_x);
						        input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, ts->touch_y);
						        input_mt_sync(ts->input_dev);
						        has_reported_point1 = TRUE;
						    }
						    if((2 == point_index) && !has_reported_point2)
						    {
              
						        TS_DEBUG_TS("report point 2\n");
						        input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, ts->touchamplitude);
						        input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, ts->sizeoftouch);
						        input_report_abs(ts->input_dev, ABS_MT_POSITION_X, ts->touch_x);
						        input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, ts->touch_y);
						        input_mt_sync(ts->input_dev);
						        has_reported_point2 = TRUE;
						    }
						/*when both points have been reported, sync this input event.*/
						    if(has_reported_point1 && has_reported_point2)
						    {
						        TS_DEBUG_TS("input_sync\n");
						        input_sync(ts->input_dev);
						        has_reported_point1 = FALSE;
						        has_reported_point2 = FALSE;
						    }
						}						
						else
						{
						/*when there is a finger lifted, is_multi_touch is FALSE, 
						  we report the releasing event.*/
					  		if ((1 << 5) & status) 
						    {
						        ts->touchamplitude = 0;	
                                ts->sizeoftouch = 0;
						    }
						    input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, ts->touchamplitude);
						    input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, ts->sizeoftouch);
						    input_report_abs(ts->input_dev, ABS_MT_POSITION_X, ts->touch_x);
						    input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, ts->touch_y);
						    input_mt_sync(ts->input_dev);
						    input_sync(ts->input_dev);
						/*reset the following values before leaving the multi_touch mode.*/
						    has_reported_point1 = FALSE;
						    has_reported_point2 = FALSE;
						    first_time_into_multi_touch = TRUE;
						/*if both touches are released, user is leaving multi_touch mode.*/
						    if(!first_point_pressed && !second_point_pressed)
						        multi_touch_mode = FALSE;
						}

					}
					else
					{
    
						    TS_DEBUG_TS("single point process\n");
						    if ((1 << 5) & status) 
						    {
						        ts->touchamplitude = 0;	
                                ts->sizeoftouch = 0;
						    }
						    input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, ts->touchamplitude);
						    input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, ts->sizeoftouch);
						    input_report_abs(ts->input_dev, ABS_MT_POSITION_X, ts->touch_x);
						    input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, ts->touch_y);
						    input_mt_sync(ts->input_dev);
						    input_sync(ts->input_dev);
					}
				}
				else
				{

					input_report_abs(ts->input_dev, ABS_X, ts->touch_x);
					input_report_abs(ts->input_dev, ABS_Y,  ts->touch_y);

					input_report_abs(ts->input_dev, ABS_PRESSURE, ts->touchamplitude);
					input_report_abs(ts->input_dev, ABS_TOOL_WIDTH, ts->sizeoftouch);
					if ((1 << 5) & status)//release bit
					{
    						input_report_key(ts->input_dev, BTN_TOUCH, 0);
					}
					else
					{
    						input_report_key(ts->input_dev, BTN_TOUCH, 1);
					}         
					input_sync(ts->input_dev);

				}

                
			}
			break;
		case TOUCH_KEYARRAY_T15:
			status = *(touch_msg + 1);
			keys = *(touch_msg + 2);
			TS_DEBUG_TS("status = 0x%02x, keys = 0x%02x\n", status, keys);
			if (keys > 0)
				TS_DEBUG_TS("~");
			else
				TS_DEBUG_TS("^");

			switch (keys)
			{
				case KEY_RELEASE:
					if (key_pressed)
					{
					 	touch_input_report_key(ts, key_pressed, 0);
						input_sync(ts->input_dev);
						key_pressed = 0;
					}
					break;
				case KEY_NUHBER1:
					if (0 == key_pressed)
					{
						if (ts->test > 0) 
							key_pressed = KEY_BRL_DOT1;
						else
							key_pressed = KEY_SEARCH;							
					 	touch_input_report_key(ts, key_pressed, 1);
						input_sync(ts->input_dev);
					}
					break;
				case KEY_NUHBER2:
					if (0 == key_pressed)
					{
						if (ts->test > 0) 
							key_pressed = KEY_BRL_DOT2;
						else
							key_pressed = KEY_MENU;
					 	touch_input_report_key(ts, key_pressed, 1);
						input_sync(ts->input_dev);
					}
					break;
				case KEY_NUHBER3:
					if (0 == key_pressed)
					{
						if (ts->test > 0) 
							key_pressed = KEY_BRL_DOT3;
						else
							key_pressed = KEY_HOME;
					 	touch_input_report_key(ts, key_pressed, 1);
						input_sync(ts->input_dev);
					}
					break;
				case KEY_NUHBER4:
					if (0 == key_pressed)
					{
						if (ts->test > 0) 
							key_pressed = KEY_BRL_DOT5;
						else
							key_pressed = KEY_BACK;
					 	touch_input_report_key(ts, key_pressed, 1);
						input_sync(ts->input_dev);
					}
					break;
				default:
					break;
			}
				
				
			break;
		default:
			TS_DEBUG_TS("T%d detect\n", obj);
			break;
	}
	
	if (ts->use_irq) {
		enable_irq(ts->client->irq);
	}
	return;
}
static enum hrtimer_restart atmel_ts_timer_func(struct hrtimer *timer)
{
	struct atmel_ts_data *ts = container_of(timer, struct atmel_ts_data, timer);
	//TS_DEBUG_TS(" atmel_ts_timer_func\n");
	queue_work(atmel_wq, &ts->work);
	hrtimer_start(&ts->timer, ktime_set(0, 200000000), HRTIMER_MODE_REL);
	return HRTIMER_NORESTART;
}

static irqreturn_t atmel_ts_irq_handler(int irq, void *dev_id)
{
	struct atmel_ts_data *ts = dev_id;
	TS_DEBUG_TS(KERN_ERR "atmel_ts_irq_handler,irq occured  disable irq\n");
	//disable_irq(ts->client->irq);
    disable_irq_nosync(ts->client->irq);
    queue_work(atmel_wq, &ts->work);
	return IRQ_HANDLED;
}

static int atmel_ts_probe(
	struct i2c_client *client,const struct i2c_device_id *id)
{
       
	struct atmel_ts_data *ts;
	int ret = 0;
	int i;
       int gpio_config;
	struct atmel_i2c_rmi_platform_data *pdata;
	struct object_t *object_table = NULL;
	u32 current_address; //the address is normal erveryone can use it
	u32 crc_calculated = 0; //crc check
	u8 tmp[3] = {0};
	int current_report_id = 0;
  
	TS_DEBUG_TS(KERN_ERR "atmel_ts_probe in");
    
    ts = NULL;
	
	g_client = client;
	
	pdata = client->dev.platform_data;

	if(pdata->power )
      {
            if(pdata->power(1) != 0)
		TS_DEBUG_TS(KERN_ERR "[%s:%d] touch power on failed!!!!!!!\n", __FILE__, __LINE__);

        }   
	
	/* Read the info block data. */
	info_block.id.family_id = 0;
	ret = read_id_block(&info_block.id);
    if(ret < 0)
    {
        printk(KERN_ERR "the slave is not decteted\n");
        goto err_slave_dectet;
    }
	for (i = 0; i < 7; i++)
	{
		TS_DEBUG_TS(KERN_ERR "ids[%d] = 0x%02x\n", i, *(((u8 *)&info_block.id) + i));
	}
	if (ATMEL_FAMILY_ID != info_block.id.family_id)
	{
		ret = -1;
		TS_DEBUG_TS(KERN_ERR "atmel_ts_probe: failed to find ATMEL IC\n");
		goto err_probe_IC_fail;
	}
	
	/* Read object table. */
	object_table = (struct object_t *) kzalloc(info_block.id.num_declared_objects * sizeof(struct object_t), GFP_KERNEL);
	if (object_table == NULL)
	{
		ret = -ENOMEM;
		TS_DEBUG_TS(KERN_ERR "atmel_ts_probe: kzalloc for object_table failed\n");
		goto err_alloc_data_failed1;
	}
	
	info_block.pobject_table = object_table;

	/* Reading the whole object table block to memory directly doesn't work cause sizeof object_t
	isn't necessarily the same on every compiler/platform due to alignment issues. Endianness
	can also cause trouble. */
	current_address = OBJECT_TABLE_START_ADDRESS;
	max_report_id = 0;
	for (i = 0; i < info_block.id.num_declared_objects; i++)
	{
		read_object_table_element(current_address + i * OBJECT_TABLE_ELEMENT_SIZE, object_table + i);
		max_report_id += (object_table + i)->num_report_ids;
      
	      /* Find out the maximum message length. */
		if ((object_table + i)->object_type == GEN_MESSAGEPROCESSOR_T5)
		{
			max_message_length = (object_table + i)->size + 1;
			TS_DEBUG_TS(KERN_ERR "max_message_length = 0x%02x\n", max_message_length);
		}
	}
		
	read_mem(OBJECT_TABLE_START_ADDRESS + info_block.id.num_declared_objects * OBJECT_TABLE_ELEMENT_SIZE, 3, tmp);
	info_block.CRC = tmp[0] | (tmp[1] << 8) | (tmp[2] << 16);
	calculate_infoblock_crc(&crc_calculated);
	TS_DEBUG_TS(KERN_ERR "info_block->CRC = 0x%08x\n", info_block.CRC);
	TS_DEBUG_TS(KERN_ERR "crc_calculated = 0x%08x\n", crc_calculated);

	if (info_block.CRC != crc_calculated)
	{	
		TS_DEBUG_TS(KERN_ERR "atmel_ts_probe: CRC not match, need reflash ROM of touch IC\n");
		goto err_power_failed;
	}
	
	/* Allocate memory for report id map now that the number of report id's 
	* is known. */
	report_id_map = (struct report_id_map_t *)kzalloc(sizeof(struct report_id_map_t) * max_report_id, GFP_KERNEL);
	if (report_id_map == NULL)
	{
		ret = -ENOMEM;
		TS_DEBUG_TS(KERN_ERR "atmel_ts_probe: kzalloc for report_id_map failed\n");
		goto err_alloc_data_failed2;
	}

	/* Report ID 0 is reserved, so start from 1. */

	report_id_map[0].instance = 0;
	report_id_map[0].object_type = 0;
	current_report_id = 1;

	for (i = 0; i < info_block.id.num_declared_objects; i++)
	{
		if ((object_table + i)->num_report_ids != 0)
		{
			int instance;
			for (instance = 0; 
				instance <= (object_table + i)->instances; 
				instance++)
			{
				int start_report_id = current_report_id;
				for (; 
					current_report_id < 
					(start_report_id + (object_table + i)->num_report_ids);
					current_report_id++)
				{
					report_id_map[current_report_id].instance = instance;
					report_id_map[current_report_id].object_type = 
					(object_table + i)->object_type;
				}
			}
		}
	}

	/* Store message processor address, it is needed often on message reads. */
	message_processor_address = get_object_address(GEN_MESSAGEPROCESSOR_T5, 0);

	/* Store command processor address. */
	command_processor_address = get_object_address(GEN_COMMANDPROCESSOR_T6, 0);
	
	/* Store command processor address. */
	debug_diagnostic_address = get_object_address(DEBUG_DIAGNOSTIC_T37, 0);
		
	/* msg. */
	touch_msg = (u8 *) kzalloc(max_message_length, GFP_KERNEL);
	if (touch_msg == NULL)
	{
		ret = -ENOMEM;
		TS_DEBUG_TS(KERN_ERR "atmel_ts_probe: kzalloc for touch_msg failed\n");
		goto err_alloc_data_failed3;
	}
	
	T9_base_reportID = type_to_report_id(TOUCH_MULTITOUCHSCREEN_T9, 0);
	
	atmel_ts_initchip();

	msleep(10);
goto succeed_find_device;
	

succeed_find_device:
	atmel_wq = create_singlethread_workqueue("atmel_wq");
	if (!atmel_wq) {
		return -ENOMEM;
	}
	ts = kzalloc(sizeof(*ts), GFP_KERNEL);
	if (ts == NULL) {
		ret = -ENOMEM;
		goto err_alloc_data_failed4;
	}

	ts->client = client;
	i2c_set_clientdata(client, ts);
	INIT_WORK(&ts->work, atmel_ts_work_func);
	ts->is_support_multi_touch = TRUE;
	ts->power = atmel_ts_power;
	if (ts->power) {
		ret = ts->power(ts->client, 1);
		if (ret < 0) {
			goto err_power_failed;
		}
		msleep(50);
	}
	
	ts->input_dev = input_allocate_device();
	if (ts->input_dev == NULL) {
		ret = -ENOMEM;
		goto err_input_dev_alloc_failed;
	}
	ts->input_dev->name = "atmel-rmi-touchscreen";
	dev_set_drvdata(&(ts->input_dev->dev), ts);
	
	set_bit(EV_SYN, ts->input_dev->evbit);
	set_bit(EV_KEY, ts->input_dev->evbit);
	set_bit(BTN_TOUCH, ts->input_dev->keybit);
	set_bit(EV_ABS, ts->input_dev->evbit);
	set_bit(ABS_X, ts->input_dev->absbit);
	set_bit(ABS_Y, ts->input_dev->absbit);

	input_set_abs_params(ts->input_dev, ABS_X, 0, TS_X_MAX, 0, 0);
#ifdef CONFIG_HUAWEI_TOUCHSCREEN_EXTRA_KEY
	input_set_abs_params(ts->input_dev, ABS_Y, 0, TS_Y_MAX - TS_KEY_Y_MAX, 0, 0);
#else
	input_set_abs_params(ts->input_dev, ABS_Y, 0, TS_Y_MAX, 0, 0);
#endif
	input_set_abs_params(ts->input_dev, ABS_PRESSURE, 0, 255, 0, 0);
	input_set_abs_params(ts->input_dev, ABS_TOOL_WIDTH, 0, 15, 0, 0);
	if(ts->is_support_multi_touch)
	{
		input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, TS_X_MAX, 0, 0);
#ifdef CONFIG_HUAWEI_TOUCHSCREEN_EXTRA_KEY
		input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, TS_Y_MAX - TS_KEY_Y_MAX, 0, 0);
#else
		input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, TS_Y_MAX, 0, 0);
#endif
		input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
		input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 15, 0, 0);
	}
	ret = input_register_device(ts->input_dev);
	if (ret) {
		goto err_input_register_device_failed;
	}
	
 #ifdef CONFIG_HUAWEI_TOUCHSCREEN_EXTRA_KEY
		ts->key_input = input_allocate_device();
		if (!ts->key_input  || !ts) {
			ret = -ENOMEM;
			goto err_input_register_device_failed;
		}
		ts->key_input->name = "touchscreen_key";
		
		set_bit(EV_KEY, ts->key_input->evbit);
		for (i = 0; i < EXTRA_MAX_TOUCH_KEY; i++)
		{
			set_bit(touch_extra_key_region.extra_key[i].touch_keycode & KEY_MAX, ts->key_input->keybit);
		}

		ret = input_register_device(ts->key_input);
		if (ret)
			goto err_key_input_register_device_failed;
#endif


       gpio_config = GPIO_CFG(ATMEL_RMI_TS_IRQ, 0, GPIO_INPUT, GPIO_PULL_UP, GPIO_2MA);//config the gpio
	ret = gpio_tlmm_config(gpio_config, GPIO_ENABLE);//return 0 or -EIO if return 0 means success or no   ????
	TS_DEBUG_TS(KERN_ERR "%s: gpio_tlmm_config(%#x)=%d\n", __func__, ATMEL_RMI_TS_IRQ, ret);
	if (ret) 
	{
		TS_DEBUG_TS(KERN_ERR "gpio_tlmm_config: gpio_tlmm_config  ATMEL_RMI_TS_IRQ failed\n");		
		ret = -EIO;
		goto err_key_input_register_device_failed;
	}

	
	ret = gpio_configure(ATMEL_RMI_TS_IRQ, GPIOF_INPUT | IRQF_TRIGGER_LOW);/*gpio 148 is interupt for touchscreen.*/
	if (ret) {
		TS_DEBUG_TS(KERN_ERR "atmel_ts_probe: gpio_configure ATMEL_RMI_TS_IRQ failed\n");
		goto err_key_input_register_device_failed;
	}

	ts->test = 0;
	if(device_create_file(&(ts->input_dev->dev), &dev_attr_test)) {
		TS_DEBUG_TS("Failed to add touch key test attrs\n");
	}

	ts->lock = 0;
	if(device_create_file(&(ts->input_dev->dev), &dev_attr_lock)) {
		TS_DEBUG_TS("Failed to add touch lock attrs\n");
	}
	
	TS_DEBUG_TS(KERN_ERR "atmel_ts_probe: client->irq = 0x%x\n", client->irq);

	if (client->irq) {
        if (gpio_request(ATMEL_RMI_TS_IRQ, client->name))
            pr_err("failed to request gpio synaptics_ts_int\n");
        
		gpio_direction_input(client->irq);

		ret = request_irq(client->irq, atmel_ts_irq_handler, IRQF_TRIGGER_LOW, client->name, ts);
		if (ret) {
			TS_DEBUG_TS(KERN_ERR "atmel_ts_probe: request irq failed, use polling way\n");
			ts->use_irq = 0;
                     TS_DEBUG_TS(KERN_ERR "atmel_ts_probe: request irq is %d,and the ret is %d\n",client->irq,ret);  
		}
		else {
			ts->use_irq = 1;
                     TS_DEBUG_TS(KERN_ERR "atmel_ts_probe:request irq the ret is %d\n",ret);
		}
	}
	
	if (!ts->use_irq) {
		hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
		ts->timer.function = atmel_ts_timer_func;
		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
		TS_DEBUG_TS(" cyj set timer\n");
	}

	//important, read msg to clear interrupt
	get_message();
    
#ifdef CONFIG_HAS_EARLYSUSPEND
	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
	ts->early_suspend.suspend = atmel_ts_early_suspend;
	ts->early_suspend.resume = atmel_ts_late_resume;
	register_early_suspend(&ts->early_suspend);
#endif

	return 0;

#ifdef CONFIG_HUAWEI_TOUCHSCREEN_EXTRA_KEY
err_key_input_register_device_failed:
	input_free_device(ts->key_input);
#endif

err_input_register_device_failed:
	input_free_device(ts->input_dev);

err_input_dev_alloc_failed:
err_power_failed:
	kfree(ts);
err_alloc_data_failed4:
	kfree(touch_msg);
err_alloc_data_failed3:
	kfree(report_id_map);
err_alloc_data_failed2:
	kfree(info_block.pobject_table);
err_alloc_data_failed1:
err_probe_IC_fail:
err_slave_dectet:
    pdata->power(0);
    printk(KERN_ERR "the atmel power is down\n");
	
	return ret;
}

static int atmel_ts_power(struct i2c_client *client, int on)
{
	return 0;
}

static int atmel_ts_remove(struct i2c_client *client)
{
	struct atmel_ts_data *ts = i2c_get_clientdata(client);

	if (ts->use_irq)
		free_irq(client->irq, ts);
	else
		hrtimer_cancel(&ts->timer);
	device_remove_file(&ts->input_dev->dev, &dev_attr_lock);
	device_remove_file(&ts->input_dev->dev, &dev_attr_test);
	input_unregister_device(ts->input_dev);
		
#ifdef CONFIG_HUAWEI_TOUCHSCREEN_EXTRA_KEY
	   input_unregister_device(ts->key_input);
#endif

	kfree(ts);
	g_client = NULL;
	kfree(touch_msg);
	kfree(report_id_map);
	kfree(info_block.pobject_table);
	return 0;
}

static int atmel_ts_suspend(struct i2c_client *client, pm_message_t mesg)
{
	int ret;
	struct atmel_ts_data *ts = i2c_get_clientdata(client);
	
	if (ts->use_irq)
		disable_irq_nosync(client->irq);
	else
		hrtimer_cancel(&ts->timer);
	ret = cancel_work_sync(&ts->work);
	if (ret && ts->use_irq) /* if work was pending disable-count is now 2 */
		enable_irq(client->irq);
    write_power_config(0);
	return 0;
}

static int atmel_ts_resume(struct i2c_client *client)
{
	struct atmel_ts_data *ts = i2c_get_clientdata(client);
    write_power_config(1);
	msleep(50);  /* wait for device reset; */
	
	if (ts->use_irq) {
		enable_irq(client->irq);
	}

	else
		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
	return 0;
}

#ifdef CONFIG_HAS_EARLYSUSPEND
static void atmel_ts_early_suspend(struct early_suspend *h)
{
	struct atmel_ts_data *ts;
	ts = container_of(h, struct atmel_ts_data, early_suspend);
	atmel_ts_suspend(ts->client, PMSG_SUSPEND);
}

static void atmel_ts_late_resume(struct early_suspend *h)
{
	struct atmel_ts_data *ts;
	ts = container_of(h, struct atmel_ts_data, early_suspend);
	atmel_ts_resume(ts->client);
}
#endif

static const struct i2c_device_id atmel_ts_id[] = {
	{ ATMEL_I2C_RMI_NAME, 0 },
	{ }
};

static struct i2c_driver atmel_ts_driver = {
	.probe		= atmel_ts_probe,
	.remove		= atmel_ts_remove,
#ifndef CONFIG_HAS_EARLYSUSPEND
	.suspend	= atmel_ts_suspend,
	.resume		= atmel_ts_resume,
#endif
	.id_table	= atmel_ts_id,
	.driver = {
	.name	= ATMEL_I2C_RMI_NAME,
	},
};

static int __devinit atmel_ts_init(void)
{
       TS_DEBUG_TS(KERN_ERR "atmel_ts init\n");
	return i2c_add_driver(&atmel_ts_driver);
}

static void __exit atmel_ts_exit(void)
{
	i2c_del_driver(&atmel_ts_driver);
	if (atmel_wq)
		destroy_workqueue(atmel_wq);
}

module_init(atmel_ts_init);
module_exit(atmel_ts_exit);

MODULE_DESCRIPTION("ATMEL Touchscreen Driver");
MODULE_LICENSE("GPL");
